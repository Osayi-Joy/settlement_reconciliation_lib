package com.osayijoy.settlement_reconciliation_lib.commonUtils.util;


import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import com.osayijoy.settlement_reconciliation_lib.config.helper.exception.ZeusRuntimeException;
import lombok.SneakyThrows;
import lombok.experimental.UtilityClass;



/**
 * API Key Generator
 * <p>
 * This class generates an API key with an expiry date using advanced cryptographic algorithms.
 * <p>
 * Cryptographic Architecture:
 * <p>
 * Algorithm:
 * - The API key generation utilizes cryptographic algorithms for enhanced security.
 * - Random bytes are generated using a secure random number generator (SecureRandom).
 * - The generated bytes are then hashed using the SHA-256 algorithm.
 * - The resulting hash is converted to a hexadecimal string representation.
 * <p>
 * Key Length:
 * - The generated API key is truncated to a maximum length of 20 characters to meet the system's requirements.
 * <p>
 * Key Expiry:
 * - The API key is associated with an expiry date to ensure its validity.
 * - The `expiryDays` parameter specifies the number of days until the API key expires.
 * - The expiry date is calculated by adding the specified number of days to the current date and time.
 * - The expiry date is appended to the API key, providing a time-limited validity period.
 * <p>
 * Keys and Algorithms:
 * - Random bytes are generated using a secure random number generator (SecureRandom) for increased entropy.
 * - The generated bytes are passed through the SHA-256 algorithm for hashing.
 * - The strength of the API key primarily depends on the cryptographic algorithms used, including the secure random number generator and the hashing algorithm.
 * <p>
 * Key Strength:
 * - The key strength is determined by the strength of the cryptographic algorithms employed.
 * - The use of a secure random number generator ensures the generation of unpredictable and cryptographically strong random bytes.
 * - The SHA-256 algorithm provides a strong cryptographic hash function, resistant to collision and pre-image attacks.
 * - The truncation of the API key to a maximum length of 20 characters ensures it remains within the system's limitations.
 * <p>
 * Example Usage:
 * <p>
 * try {
 *     String apiKey = ApiKeyGenerator.generateApiKey();
 *     System.out.println("Generated API Key: " + apiKey);
 * } catch (NoSuchAlgorithmException e) {
 *     e.printStackTrace();
 * }
 * <p>
 * Note:
 * - The code provided employs advanced cryptographic algorithms (SecureRandom and SHA-256) to generate a secure API key.
 * - The API key generation process ensures a time-limited validity period by appending an expiry date.
 * - It is crucial to handle the NoSuchAlgorithmException appropriately when invoking the `generateApiKey` method.
 * - For higher security requirements, consider customizing the cryptographic algorithms and key length as per your specific needs.
 */
@UtilityClass
public class ApiKeyGenerator {
    private static final int MAX_KEY_LENGTH = 20;
    private static final int EXPIRY_DAYS = 365;

    private static final int KEY_LENGTH = 256; // AES 256-bit key


    public  String generateApiKey() {
        byte[] randomBytes = generateRandomBytes();
        byte[] hashedBytes = generateHash(randomBytes);
        String apiKey = bytesToHex(hashedBytes);

        // Truncate if necessary
        if (apiKey.length() > MAX_KEY_LENGTH) {
            apiKey = apiKey.substring(0, MAX_KEY_LENGTH);
        }

        // Append expiry date
        LocalDateTime expiryDateTime = LocalDateTime.now().plusDays(EXPIRY_DAYS);
        String formattedExpiry = expiryDateTime.format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));
        apiKey += formattedExpiry;

        return apiKey;
    }

    private  byte[] generateRandomBytes() {
        SecureRandom secureRandom = new SecureRandom();
        byte[] randomBytes = new byte[16];
        secureRandom.nextBytes(randomBytes);
        return randomBytes;
    }

    @SneakyThrows
    private  byte[] generateHash(byte[] data) {

        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        return digest.digest(data);

    }

    private  String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02X", b));
        }
        return result.toString();
    }

    public static String generateAESKey()  {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            keyGenerator.init(128); // 128 bits for AES key length
            SecretKey secretKey = keyGenerator.generateKey();
            byte[] encodedKey = secretKey.getEncoded();
            return byteArrayToHexString(encodedKey);
        } catch (NoSuchAlgorithmException e) {
            throw new ZeusRuntimeException(e.getMessage());
        }
    }

    public static String byteArrayToHexString(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02X", b));
        }
        return result.toString();
    }

}


